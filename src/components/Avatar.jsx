/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
Command: npx gltfjsx@6.2.3 public/models/646d9dcdc8a5f5bddbfac913.glb -o src/components/Avatar.jsx -r public
*/

import { useAnimations, useFBX, useGLTF } from "@react-three/drei";
import { useFrame } from "@react-three/fiber";
import { useControls } from "leva";
import React, { useEffect, useMemo, useRef, useState, forwardRef, useImperativeHandle } from "react";
import * as THREE from "three";

const corresponding = {
  A: "viseme_PP",
  B: "viseme_kk",
  C: "viseme_I",
  D: "viseme_AA",
  E: "viseme_O",
  F: "viseme_U",
  G: "viseme_FF",
  H: "viseme_TH",
  X: "viseme_PP",
};

export const Avatar = forwardRef(({ preguntas, ...props }, ref) => {
  const audioData = useMemo(() => ({
    welcome: {
      audio: new Audio("/audios/welcome.mp3"),
      lipsync: "/audios/welcome.json"
    },
    aprove1: {
      audio: new Audio("/audios/aprove1.mp3"),
      lipsync: "/audios/aprove1.json"
    },
    aprove2: {
      audio: new Audio("/audios/aprove2.mp3"),
      lipsync: "/audios/aprove2.json"
    },
    aprove3: {
      audio: new Audio("/audios/aprove3.mp3"),
      lipsync: "/audios/aprove3.json"
    },
    bienvenida2: {
      audio: new Audio("/audios/bienvenida2.mp3"),
      lipsync: "/audios/bienvenida2.json"
    },
    bienvenida3: {
      audio: new Audio("/audios/bienvenida3.mp3"),
      lipsync: "/audios/bienvenida3.json"
    },
    despedida1: {
      audio: new Audio("/audios/despedida1.mp3"),
      lipsync: "/audios/despedida1.json"
    },
    despedida2: {
      audio: new Audio("/audios/despedida2.mp3"),
      lipsync: "/audios/despedida2.json"
    },
    despedida3: {
      audio: new Audio("/audios/despedida3.mp3"),
      lipsync: "/audios/despedida3.json"
    },
    equivocado1: {
      audio: new Audio("/audios/equivocado1.mp3"),
      lipsync: "/audios/equivocado1.json"
    },
    equivocado2: {
      audio: new Audio("/audios/equivocado2.mp3"),
      lipsync: "/audios/equivocado2.json"
    },
    equivocado3: {
      audio: new Audio("/audios/equivocado3.mp3"),
      lipsync: "/audios/equivocado3.json"
    },
    relleno1: {
      audio: new Audio("/audios/relleno1.mp3"),
      lipsync: "/audios/relleno1.json"
    }
  }), []);

  const audioToAnimation = {
    welcome: "Greeting",
    aprove1: "Clapping",
    aprove2: "Acknowledging",
    aprove3: "Salute",
    bienvenida2: "ThoughfulHeadShake",
    bienvenida3: "PointForward",
    despedida1: "Defeated",
    despedida2: "Defeat",
    despedida3: "Yelling",
    equivocado1: "Angry",
    equivocado2: "Angry2",
    equivocado3: "Surprised",
    relleno1: "Surprised"
  };

  const [isPlaying, setIsPlaying] = useState(false);
  const [animation, setAnimation] = useState("Idle");
  const [currentLipsync, setCurrentLipsync] = useState(null);
  const [currentAudio, setCurrentAudio] = useState(null);
  const [hasPlayedWelcome, setHasPlayedWelcome] = useState(false);
  const rellenoInterval = useRef(null);

  const { nodes, materials } = useGLTF("/models/6823856055fa435d140c3f37 (1).glb");
  
  // Cargar animaciones
  const { animations: idleAnimation } = useFBX("/animations/Idle.fbx");
  const { animations: angryAnimation } = useFBX("/animations/Angry Gesture.fbx");
  const { animations: greetingAnimation } = useFBX("/animations/Standing Greeting.fbx");
  const { animations: AcknowledgingAnimation } = useFBX("/animations/Acknowledging.fbx");
  const { animations: Angry2Animation } = useFBX("/animations/Angry.fbx");
  const { animations: ClappingAnimation } = useFBX("/animations/Clapping.fbx");
  const { animations: DefeatAnimation } = useFBX("/animations/Defeat.fbx");
  const { animations: DefeatedAnimation } = useFBX("/animations/Defeated.fbx");
  const { animations: PointForwardAnimation } = useFBX("/animations/Pointing Forward.fbx");
  const { animations: SaluteAnimation } = useFBX("/animations/Salute.fbx");
  const { animations: SurprisedAnimation } = useFBX("/animations/Surprised.fbx");
  const { animations: ThoughfulHeadShakeAnimation } = useFBX("/animations/Thoughtful Head Shake.fbx");
  const { animations: YellingAnimation } = useFBX("/animations/Yelling.fbx");

  // Asignar nombres y normalizar animaciones
  idleAnimation[0].name = "Idle";
  angryAnimation[0].name = "Angry";
  greetingAnimation[0].name = "Greeting";
  AcknowledgingAnimation[0].name = "Acknowledging";
  Angry2Animation[0].name = "Angry2";
  ClappingAnimation[0].name = "Clapping";
  DefeatAnimation[0].name = "Defeat";
  DefeatedAnimation[0].name = "Defeated";
  PointForwardAnimation[0].name = "PointForward";
  SaluteAnimation[0].name = "Salute";
  SurprisedAnimation[0].name = "Surprised";
  ThoughfulHeadShakeAnimation[0].name = "ThoughfulHeadShake";
  YellingAnimation[0].name = "Yelling";

  const group = useRef();
  const { actions } = useAnimations(
    [
      idleAnimation[0],
      angryAnimation[0],
      greetingAnimation[0],
      AcknowledgingAnimation[0],
      Angry2Animation[0],
      ClappingAnimation[0],
      DefeatAnimation[0],
      DefeatedAnimation[0],
      PointForwardAnimation[0],
      SaluteAnimation[0],
      SurprisedAnimation[0],
      ThoughfulHeadShakeAnimation[0],
      YellingAnimation[0]
    ],
    group
  );

  const {
    headFollow,
    smoothMorphTarget,
    morphTargetSmoothing,
  } = useControls({
    headFollow: true,
    smoothMorphTarget: true,
    morphTargetSmoothing: 0.5,
  });

  const playAudioWithAnimation = (audioKey) => {
    const audioInfo = audioData[audioKey];
    if (!audioInfo) return;

    Object.values(audioData).forEach(({audio}) => {
      audio.pause();
      audio.currentTime = 0;
    });

    fetch(audioInfo.lipsync)
      .then(response => response.json())
      .then(lipsync => {
        setCurrentLipsync(lipsync);
        setCurrentAudio(audioInfo.audio);
        
        audioInfo.audio.play()
          .then(() => {
            setIsPlaying(true);
            setAnimation(audioToAnimation[audioKey]);
            
            audioInfo.audio.onended = () => {
              setIsPlaying(false);
              setAnimation("Idle");
              setCurrentLipsync(null);
              setCurrentAudio(null);
              
              setTimeout(() => {
                setHasPlayedWelcome(true);
              }, 2000);
            };
          })
          .catch(error => {
            console.error("Error al reproducir:", error);
          });
      })
      .catch(error => {
        console.error("Error cargando lipsync:", error);
      });
  };

  const startRellenoLoop = () => {
    if (preguntas && preguntas.length > 0) return;
    
    rellenoInterval.current = setInterval(() => {
      if (!isPlaying && hasPlayedWelcome) {
        playAudioWithAnimation("relleno1");
      }
    }, 5000);
    
    if (hasPlayedWelcome) {
      playAudioWithAnimation("relleno1");
    }
  };

  const stopRellenoLoop = () => {
    if (rellenoInterval.current) {
      clearInterval(rellenoInterval.current);
      rellenoInterval.current = null;
    }
  };

  // Efecto para el audio y animaciones
  useEffect(() => {
    const timer = setTimeout(() => {
      playAudioWithAnimation("welcome");
    }, 2000);

    return () => {
      clearTimeout(timer);
      stopRellenoLoop();
      Object.values(audioData).forEach(({audio}) => {
        audio.pause();
        audio.currentTime = 0;
      });
    };
  }, []);

  useEffect(() => {
    if (hasPlayedWelcome) {
      startRellenoLoop();
    }
    
    if (preguntas?.length > 0) {
      stopRellenoLoop();
    }
    
    return () => stopRellenoLoop();
  }, [hasPlayedWelcome, preguntas]);

  // Control de animaciones y posición
  useEffect(() => {
    if (actions[animation]) {
      // Resetear la posición de la cadera antes de cada animación
      const hips = group.current?.getObjectByName("Hips");
      if (hips) {
        hips.position.set(0, 0, 0);
        hips.rotation.set(0, 0, 0);
      }

      actions[animation].reset().fadeIn(0.5).play();
    }
    return () => {
      if (actions[animation]) {
        actions[animation].fadeOut(0.5);
      }
    };
  }, [animation, actions]);

  // Frame loop para lipsync y posición
  useFrame((state) => {
    // Mantener la posición del avatar estable
    const hips = group.current?.getObjectByName("Hips");
    if (hips) {
      hips.position.y = 0;
      hips.rotation.x = 0;
      hips.rotation.z = 0;
    }

    // Control de cabeza
    if (headFollow) {
      group.current?.getObjectByName("Head")?.lookAt(state.camera.position);
    }

    // Lipsync
    if (!isPlaying || !currentAudio || !currentLipsync) return;

    const currentAudioTime = currentAudio.currentTime;
    if (currentAudio.paused || currentAudio.ended) return;

    Object.values(corresponding).forEach((value) => {
      if (!smoothMorphTarget) {
        nodes.Wolf3D_Head.morphTargetInfluences[
          nodes.Wolf3D_Head.morphTargetDictionary[value]
        ] = 0;
        nodes.Wolf3D_Teeth.morphTargetInfluences[
          nodes.Wolf3D_Teeth.morphTargetDictionary[value]
        ] = 0;
      } else {
        nodes.Wolf3D_Head.morphTargetInfluences[
          nodes.Wolf3D_Head.morphTargetDictionary[value]
        ] = THREE.MathUtils.lerp(
          nodes.Wolf3D_Head.morphTargetInfluences[
            nodes.Wolf3D_Head.morphTargetDictionary[value]
          ],
          0,
          morphTargetSmoothing
        );

        nodes.Wolf3D_Teeth.morphTargetInfluences[
          nodes.Wolf3D_Teeth.morphTargetDictionary[value]
        ] = THREE.MathUtils.lerp(
          nodes.Wolf3D_Teeth.morphTargetInfluences[
            nodes.Wolf3D_Teeth.morphTargetDictionary[value]
          ],
          0,
          morphTargetSmoothing
        );
      }
    });

    for (let i = 0; i < currentLipsync.mouthCues.length; i++) {
      const mouthCue = currentLipsync.mouthCues[i];
      if (currentAudioTime >= mouthCue.start && currentAudioTime <= mouthCue.end) {
        const value = corresponding[mouthCue.value];
        if (!smoothMorphTarget) {
          nodes.Wolf3D_Head.morphTargetInfluences[
            nodes.Wolf3D_Head.morphTargetDictionary[value]
          ] = 1;
          nodes.Wolf3D_Teeth.morphTargetInfluences[
            nodes.Wolf3D_Teeth.morphTargetDictionary[value]
          ] = 1;
        } else {
          nodes.Wolf3D_Head.morphTargetInfluences[
            nodes.Wolf3D_Head.morphTargetDictionary[value]
          ] = THREE.MathUtils.lerp(
            nodes.Wolf3D_Head.morphTargetInfluences[
              nodes.Wolf3D_Head.morphTargetDictionary[value]
            ],
            1,
            morphTargetSmoothing
          );
          nodes.Wolf3D_Teeth.morphTargetInfluences[
            nodes.Wolf3D_Teeth.morphTargetDictionary[value]
          ] = THREE.MathUtils.lerp(
            nodes.Wolf3D_Teeth.morphTargetInfluences[
              nodes.Wolf3D_Teeth.morphTargetDictionary[value]
            ],
            1,
            morphTargetSmoothing
          );
        }
        break;
      }
    }
  });

  useImperativeHandle(ref, () => ({
    playAudioWithAnimation
  }));

  return (
    <group position={[0, -1, 0]} rotation={[0, Math.PI, 0]}>
      <group ref={group} {...props}>
        <primitive object={nodes.Hips} />
        <skinnedMesh
          geometry={nodes.Wolf3D_Body.geometry}
          material={materials.Wolf3D_Body}
          skeleton={nodes.Wolf3D_Body.skeleton}
        />
        <skinnedMesh
          geometry={nodes.Wolf3D_Outfit_Bottom.geometry}
          material={materials.Wolf3D_Outfit_Bottom}
          skeleton={nodes.Wolf3D_Outfit_Bottom.skeleton}
        />
        <skinnedMesh
          geometry={nodes.Wolf3D_Outfit_Footwear.geometry}
          material={materials.Wolf3D_Outfit_Footwear}
          skeleton={nodes.Wolf3D_Outfit_Footwear.skeleton}
        />
        <skinnedMesh
          geometry={nodes.Wolf3D_Outfit_Top.geometry}
          material={materials.Wolf3D_Outfit_Top}
          skeleton={nodes.Wolf3D_Outfit_Top.skeleton}
        />
        <skinnedMesh
          geometry={nodes.Wolf3D_Hair.geometry}
          material={materials.Wolf3D_Hair}
          skeleton={nodes.Wolf3D_Hair.skeleton}
        />
        <skinnedMesh
          name="EyeLeft"
          geometry={nodes.EyeLeft.geometry}
          material={materials.Wolf3D_Eye}
          skeleton={nodes.EyeLeft.skeleton}
          morphTargetDictionary={nodes.EyeLeft.morphTargetDictionary}
          morphTargetInfluences={nodes.EyeLeft.morphTargetInfluences}
        />
        <skinnedMesh
          name="EyeRight"
          geometry={nodes.EyeRight.geometry}
          material={materials.Wolf3D_Eye}
          skeleton={nodes.EyeRight.skeleton}
          morphTargetDictionary={nodes.EyeRight.morphTargetDictionary}
          morphTargetInfluences={nodes.EyeRight.morphTargetInfluences}
        />
        <skinnedMesh
          name="Wolf3D_Head"
          geometry={nodes.Wolf3D_Head.geometry}
          material={materials.Wolf3D_Skin}
          skeleton={nodes.Wolf3D_Head.skeleton}
          morphTargetDictionary={nodes.Wolf3D_Head.morphTargetDictionary}
          morphTargetInfluences={nodes.Wolf3D_Head.morphTargetInfluences}
        />
        <skinnedMesh
          name="Wolf3D_Teeth"
          geometry={nodes.Wolf3D_Teeth.geometry}
          material={materials.Wolf3D_Teeth}
          skeleton={nodes.Wolf3D_Teeth.skeleton}
          morphTargetDictionary={nodes.Wolf3D_Teeth.morphTargetDictionary}
          morphTargetInfluences={nodes.Wolf3D_Teeth.morphTargetInfluences}
        />
      </group>
    </group>
  );
});

useGLTF.preload("/models/6823856055fa435d140c3f37 (1).glb");