/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
Command: npx gltfjsx@6.2.3 public/models/646d9dcdc8a5f5bddbfac913.glb -o src/components/Avatar.jsx -r public
*/

import { useAnimations, useFBX, useGLTF } from "@react-three/drei";
import { useFrame, useLoader } from "@react-three/fiber";
import { useControls } from "leva";
import React, { useEffect, useMemo, useRef, useState, forwardRef, useImperativeHandle  } from "react";
import * as THREE from "three";

const corresponding = {
  A: "viseme_PP",
  B: "viseme_kk",
  C: "viseme_I",
  D: "viseme_AA",
  E: "viseme_O",
  F: "viseme_U",
  G: "viseme_FF",
  H: "viseme_TH",
  X: "viseme_PP",
};

export const Avatar = forwardRef(({ preguntas, ...props }, ref) => {
  // Lista de todos los audios disponibles con sus respectivos lipsync
  const audioData = useMemo(() => ({
    welcome: {
      audio: new Audio("/audios/welcome.mp3"),
      lipsync: "/audios/welcome.json"
    },
    aprove1: {
      audio: new Audio("/audios/aprove1.mp3"),
      lipsync: "/audios/aprove1.json"
    },
    aprove2: {
      audio: new Audio("/audios/aprove2.mp3"),
      lipsync: "/audios/aprove2.json"
    },
    aprove3: {
      audio: new Audio("/audios/aprove3.mp3"),
      lipsync: "/audios/aprove3.json"
    },
    bienvenida2: {
      audio: new Audio("/audios/bienvenida2.mp3"),
      lipsync: "/audios/bienvenida2.json"
    },
    bienvenida3: {
      audio: new Audio("/audios/bienvenida3.mp3"),
      lipsync: "/audios/bienvenida3.json"
    },
    despedida1: {
      audio: new Audio("/audios/despedida1.mp3"),
      lipsync: "/audios/despedida1.json"
    },
    despedida2: {
      audio: new Audio("/audios/despedida2.mp3"),
      lipsync: "/audios/despedida2.json"
    },
    despedida3: {
      audio: new Audio("/audios/despedida3.mp3"),
      lipsync: "/audios/despedida3.json"
    },
    equivocado1: {
      audio: new Audio("/audios/equivocado1.mp3"),
      lipsync: "/audios/equivocado1.json"
    },
    equivocado2: {
      audio: new Audio("/audios/equivocado2.mp3"),
      lipsync: "/audios/equivocado2.json"
    },
    equivocado3: {
      audio: new Audio("/audios/equivocado3.mp3"),
      lipsync: "/audios/equivocado3.json"
    },
    relleno1: {
      audio: new Audio("/audios/relleno1.mp3"),
      lipsync: "/audios/relleno1.json"
    }
  }), []);

  // Mapeo de audios a animaciones correspondientes
  const audioToAnimation = {
    welcome: "Greeting",
    aprove1: "Clapping",
    aprove2: "Acknowledging",
    aprove3: "Salute",
    bienvenida2: "ThoughfulHeadShake",
    bienvenida3: "PointForward",
    despedida1: "Defeated",
    despedida2: "Defeat",
    despedida3: "Yelling",
    equivocado1: "Angry",
    equivocado2: "Angry2",
    equivocado3: "Surprised",
    relleno1: "Surprised"
  };

  const [isPlaying, setIsPlaying] = useState(false);
  const [animation, setAnimation] = useState("Idle");
  const [currentLipsync, setCurrentLipsync] = useState(null);
  const [currentAudio, setCurrentAudio] = useState(null);
  const [hasPlayedWelcome, setHasPlayedWelcome] = useState(false);
  const rellenoInterval = useRef(null);
  

  const playAudioWithAnimation = (audioKey) => {
    const audioInfo = audioData[audioKey];
    if (!audioInfo) return;

    // Detener cualquier audio previo
    Object.values(audioData).forEach(({audio}) => {
      audio.pause();
      audio.currentTime = 0;
    });

    // Cargar el lipsync correspondiente
    fetch(audioInfo.lipsync)
      .then(response => response.json())
      .then(lipsync => {
        setCurrentLipsync(lipsync);
        setCurrentAudio(audioInfo.audio);
        
        audioInfo.audio.play()
          .then(() => {
            setIsPlaying(true);
            setAnimation(audioToAnimation[audioKey]);
            
            audioInfo.audio.onended = () => {
              setIsPlaying(false);
              setAnimation("Idle");
              setCurrentLipsync(null);
              setCurrentAudio(null);
              
              // Esperar 2 segundos ANTES de marcar como reproducido
              setTimeout(() => {
                setHasPlayedWelcome(true);
              }, 2000); // 2000 ms = 2 segundos
            };
          })
          .catch(error => {
            console.error("Error al reproducir:", error);
          });
      })
      .catch(error => {
        console.error("Error cargando lipsync:", error);
      });
  };

  const startRellenoLoop = () => {
    // Si ya hay preguntas, no iniciamos el loop
    if (preguntas && preguntas.length > 0) return;
    
    // Reproducir el audio de relleno cada 10 segundos
    rellenoInterval.current = setInterval(() => {
      if (!isPlaying && hasPlayedWelcome) {
        playAudioWithAnimation("relleno1");
      }
    }, 5000); // 10 segundos entre reproducciones
    
    // Primera reproducci√≥n inmediata despu√©s del welcome
    if (hasPlayedWelcome) {
      playAudioWithAnimation("relleno1");
    }
  };

  const stopRellenoLoop = () => {
    if (rellenoInterval.current) {
      clearInterval(rellenoInterval.current);
      rellenoInterval.current = null;
    }
  };

  useEffect(() => {
    // Reproducir solo el audio de bienvenida al inicio
    const timer = setTimeout(() => {
      playAudioWithAnimation("welcome");
    }, 2000);

    return () => {
      clearTimeout(timer);
      stopRellenoLoop();
      Object.values(audioData).forEach(({audio}) => {
        audio.pause();
        audio.currentTime = 0;
      });
    };
  }, []);

useEffect(() => {
  if (hasPlayedWelcome) {
    startRellenoLoop(); // Esto ya incluye la primera reproducci√≥n
  }
  
  if (preguntas?.length > 0) {
    stopRellenoLoop();
  }
  
  return () => stopRellenoLoop();
}, [hasPlayedWelcome, preguntas]);
  const {
    headFollow,
    smoothMorphTarget,
    morphTargetSmoothing,
  } = useControls({
    headFollow: true,
    smoothMorphTarget: true,
    morphTargetSmoothing: 0.5,
  });

  useFrame(() => {
    if (!isPlaying || !currentAudio || !currentLipsync) return;

    const currentAudioTime = currentAudio.currentTime;
    if (currentAudio.paused || currentAudio.ended) {
      setAnimation("Idle");
      return;
    }

    // Resetear todos los morph targets
    Object.values(corresponding).forEach((value) => {
      if (!smoothMorphTarget) {
        nodes.Wolf3D_Head.morphTargetInfluences[
          nodes.Wolf3D_Head.morphTargetDictionary[value]
        ] = 0;
        nodes.Wolf3D_Teeth.morphTargetInfluences[
          nodes.Wolf3D_Teeth.morphTargetDictionary[value]
        ] = 0;
      } else {
        nodes.Wolf3D_Head.morphTargetInfluences[
          nodes.Wolf3D_Head.morphTargetDictionary[value]
        ] = THREE.MathUtils.lerp(
          nodes.Wolf3D_Head.morphTargetInfluences[
            nodes.Wolf3D_Head.morphTargetDictionary[value]
          ],
          0,
          morphTargetSmoothing
        );

        nodes.Wolf3D_Teeth.morphTargetInfluences[
          nodes.Wolf3D_Teeth.morphTargetDictionary[value]
        ] = THREE.MathUtils.lerp(
          nodes.Wolf3D_Teeth.morphTargetInfluences[
            nodes.Wolf3D_Teeth.morphTargetDictionary[value]
          ],
          0,
          morphTargetSmoothing
        );
      }
    });

    // Aplicar el morph target actual seg√∫n el lipsync
    for (let i = 0; i < currentLipsync.mouthCues.length; i++) {
      const mouthCue = currentLipsync.mouthCues[i];
      if (
        currentAudioTime >= mouthCue.start &&
        currentAudioTime <= mouthCue.end
      ) {
        if (!smoothMorphTarget) {
          nodes.Wolf3D_Head.morphTargetInfluences[
            nodes.Wolf3D_Head.morphTargetDictionary[
              corresponding[mouthCue.value]
            ]
          ] = 1;
          nodes.Wolf3D_Teeth.morphTargetInfluences[
            nodes.Wolf3D_Teeth.morphTargetDictionary[
              corresponding[mouthCue.value]
            ]
          ] = 1;
        } else {
          nodes.Wolf3D_Head.morphTargetInfluences[
            nodes.Wolf3D_Head.morphTargetDictionary[
              corresponding[mouthCue.value]
            ]
          ] = THREE.MathUtils.lerp(
            nodes.Wolf3D_Head.morphTargetInfluences[
              nodes.Wolf3D_Head.morphTargetDictionary[
                corresponding[mouthCue.value]
              ]
            ],
            1,
            morphTargetSmoothing
          );
          nodes.Wolf3D_Teeth.morphTargetInfluences[
            nodes.Wolf3D_Teeth.morphTargetDictionary[
              corresponding[mouthCue.value]
            ]
          ] = THREE.MathUtils.lerp(
            nodes.Wolf3D_Teeth.morphTargetInfluences[
              nodes.Wolf3D_Teeth.morphTargetDictionary[
                corresponding[mouthCue.value]
              ]
            ],
            1,
            morphTargetSmoothing
          );
        }
        break;
      }
    }
  });

  // useEffect(() => {
  //   nodes.Wolf3D_Head.morphTargetInfluences[
  //     nodes.Wolf3D_Head.morphTargetDictionary["viseme_I"]
  //   ] = 1;
  //   nodes.Wolf3D_Teeth.morphTargetInfluences[
  //     nodes.Wolf3D_Teeth.morphTargetDictionary["viseme_I"]
  //   ] = 1;
  //   if (playAudio) {
  //     audio.play();
  //     if (script === "welcome") {
  //       setAnimation("Greeting");
  //     } else {
  //       setAnimation("Angry");
  //     }
  //   } else {
  //     setAnimation("Idle");
  //     audio.pause();
  //   }
  // }, [playAudio, script]);

  // const { nodes, materials } = useGLTF("/models/646d9dcdc8a5f5bddbfac913.glb");
  // const { nodes, materials } = useGLTF("/models/6823b9533c5ab94b9e566250.glb");
  const { nodes, materials } = useGLTF("/models/formal1.glb");
  const { animations: idleAnimation } = useFBX("/animations/Defeated (1).fbx");
  const { animations: angryAnimation } = useFBX("/animations/Angry Gesture.fbx");
  const { animations: greetingAnimation } = useFBX("/animations/Standing Greeting.fbx");
  const { animations: AcknowledgingAnimation } = useFBX("/animations/Acknowledging.fbx");
  const { animations: Angry2Animation } = useFBX("/animations/Angry.fbx");
  const { animations: ClappingAnimation } = useFBX("/animations/Clapping.fbx");
  const { animations: CockyHeadTurnAnimation } = useFBX("/animations/Cocky Head Turn.fbx");
  const { animations: DefeatAnimation } = useFBX("/animations/Defeat.fbx");
  const { animations: DefeatedAnimation } = useFBX("/animations/Defeated.fbx");
  const { animations: ofensiveAnimation } = useFBX("/animations/Offensive Idle.fbx");
  const { animations: PointForwardAnimation } = useFBX("/animations/Pointing Forward.fbx");
  const { animations: SaluteAnimation } = useFBX("/animations/Salute.fbx");
  const { animations: SurprisedAnimation } = useFBX("/animations/Surprised.fbx");
  const { animations: ThoughfulHeadShakeAnimation } = useFBX("/animations/Thoughtful Head Shake.fbx");
  const { animations: YellingAnimation } = useFBX("/animations/Yelling.fbx");

  // Asignar nombres a las animaciones
  idleAnimation[0].name = "Idle";
  angryAnimation[0].name = "Angry";
  greetingAnimation[0].name = "Greeting";
  AcknowledgingAnimation[0].name = "Acknowledging";
  Angry2Animation[0].name = "Angry2";
  ClappingAnimation[0].name = "Clapping";
  CockyHeadTurnAnimation[0].name = "CockyHeadTurn";
  DefeatAnimation[0].name = "Defeat";
  DefeatedAnimation[0].name = "Defeated";
  ofensiveAnimation[0].name = "ofensive";
  PointForwardAnimation[0].name = "PointForward";
  SaluteAnimation[0].name = "Salute";
  SurprisedAnimation[0].name = "Surprised";
  ThoughfulHeadShakeAnimation[0].name = "ThoughfulHeadShake";
  YellingAnimation[0].name = "Yelling";

  const group = useRef();
  const { actions } = useAnimations(
    [
      idleAnimation[0], 
      angryAnimation[0], 
      greetingAnimation[0],
      AcknowledgingAnimation[0],
      Angry2Animation[0],
      ClappingAnimation[0],
      CockyHeadTurnAnimation[0],
      DefeatAnimation[0],
      DefeatedAnimation[0],
      ofensiveAnimation[0],
      PointForwardAnimation[0],
      SaluteAnimation[0],
      SurprisedAnimation[0],
      ThoughfulHeadShakeAnimation[0],
      YellingAnimation[0]
    ],
    group
  );

  useImperativeHandle(ref, () => ({
    playAudioWithAnimation
  }));

  useEffect(() => {
    if (!actions[animation] || !group.current) return;
  
    // üîÅ Corrige la rotaci√≥n para que el personaje no est√© acostado
    group.current.rotation.set(-Math.PI / 2, 0, 0); // o prueba con Math.PI / 2 si esto no es suficiente
  
    actions[animation].reset().fadeIn(0.5).play();
    return () => actions[animation].fadeOut(0.5);
  }, [animation]);
  
  

  useFrame((state) => {
    if (headFollow) {
      group.current.getObjectByName("Head").lookAt(state.camera.position);
    }
  });

  useEffect(() => {
    if (!preguntas || preguntas.length === 0) return;

    const primera = preguntas[0];
    const texto = `${primera.pregunta}. 
    A: ${primera.incisos.A}, 
    B: ${primera.incisos.B}, 
    C: ${primera.incisos.C}.`;

    const speech = new SpeechSynthesisUtterance(texto);
    speech.lang = "es-ES";
    window.speechSynthesis.speak(speech);

    setAnimation("Greeting");
  }, [preguntas]);

  return (
    <group {...props} dispose={null} ref={group}>
      <primitive object={nodes.Hips} />
      <skinnedMesh
        geometry={nodes.Wolf3D_Body.geometry}
        material={materials.Wolf3D_Body}
        skeleton={nodes.Wolf3D_Body.skeleton}
      />
      <skinnedMesh
        geometry={nodes.Wolf3D_Outfit_Bottom.geometry}
        material={materials.Wolf3D_Outfit_Bottom}
        skeleton={nodes.Wolf3D_Outfit_Bottom.skeleton}
      />
      <skinnedMesh
        geometry={nodes.Wolf3D_Outfit_Footwear.geometry}
        material={materials.Wolf3D_Outfit_Footwear}
        skeleton={nodes.Wolf3D_Outfit_Footwear.skeleton}
      />
      <skinnedMesh
        geometry={nodes.Wolf3D_Outfit_Top.geometry}
        material={materials.Wolf3D_Outfit_Top}
        skeleton={nodes.Wolf3D_Outfit_Top.skeleton}
      />
      <skinnedMesh
        geometry={nodes.Wolf3D_Hair.geometry}
        material={materials.Wolf3D_Hair}
        skeleton={nodes.Wolf3D_Hair.skeleton}
      />
      <skinnedMesh
        name="EyeLeft"
        geometry={nodes.EyeLeft.geometry}
        material={materials.Wolf3D_Eye}
        skeleton={nodes.EyeLeft.skeleton}
        morphTargetDictionary={nodes.EyeLeft.morphTargetDictionary}
        morphTargetInfluences={nodes.EyeLeft.morphTargetInfluences}
      />
      <skinnedMesh
        name="EyeRight"
        geometry={nodes.EyeRight.geometry}
        material={materials.Wolf3D_Eye}
        skeleton={nodes.EyeRight.skeleton}
        morphTargetDictionary={nodes.EyeRight.morphTargetDictionary}
        morphTargetInfluences={nodes.EyeRight.morphTargetInfluences}
      />
      <skinnedMesh
        name="Wolf3D_Head"
        geometry={nodes.Wolf3D_Head.geometry}
        material={materials.Wolf3D_Skin}
        skeleton={nodes.Wolf3D_Head.skeleton}
        morphTargetDictionary={nodes.Wolf3D_Head.morphTargetDictionary}
        morphTargetInfluences={nodes.Wolf3D_Head.morphTargetInfluences}
      />
      <skinnedMesh
        name="Wolf3D_Teeth"
        geometry={nodes.Wolf3D_Teeth.geometry}
        material={materials.Wolf3D_Teeth}
        skeleton={nodes.Wolf3D_Teeth.skeleton}
        morphTargetDictionary={nodes.Wolf3D_Teeth.morphTargetDictionary}
        morphTargetInfluences={nodes.Wolf3D_Teeth.morphTargetInfluences}
      />
    </group>
  );
});

useGLTF.preload("/models/646d9dcdc8a5f5bddbfac913.glb");